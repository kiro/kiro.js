// Generated by CoffeeScript 1.4.0
(function() {

  window.BC.define('models', function(models) {
    var assertArray, common;
    common = window.BC.namespace("common");
    assertArray = function(arr) {
      if (!_.isArray(arr)) {
        throw Error(arr + " is expected to be an array");
      }
    };
    return models.collection = function(initial) {
      var allItems, collection, filter, items, o, toPredicate, update;
      if (initial == null) {
        initial = [];
      }
      assertArray(initial);
      allItems = initial;
      items = allItems;
      o = common.observable();
      filter = function() {
        return true;
      };
      collection = function(arg) {
        if (_.isUndefined(arg)) {
          return items;
        } else {
          assertArray(arg);
          allItems = arg;
          return update();
        }
      };
      update = function() {
        items = _.filter(allItems, filter);
        return o.publish(items);
      };
      toPredicate = function(arg) {
        if (_.isFunction(arg)) {
          return arg;
        } else {
          return function(item) {
            return item === arg;
          };
        }
      };
      collection.add = function(arg) {
        allItems.push(arg);
        return update.call(collection);
      };
      collection.addAll = function(items) {
        assertArray(items);
        allItems = allItems.concat(items);
        return update.call(collection);
      };
      collection.remove = function(arg) {
        var predicate;
        predicate = toPredicate(arg);
        allItems = _.filter(allItems, function(item) {
          return !predicate(item);
        });
        return update.call(collection);
      };
      collection.removeAll = function() {
        allItems = [];
        return update.call(collection);
      };
      collection.filter = function(arg) {
        filter = toPredicate(arg);
        return update.call(collection);
      };
      collection.count = function(arg) {
        if (_.isUndefined(arg)) {
          return items.length;
        } else if (_.isFunction(arg)) {
          return _.reduce(items, (function(memo, item) {
            if (arg(item)) {
              return 1 + memo;
            } else {
              return memo;
            }
          }), 0);
        } else {
          throw Error(arg + " is expected to be function or undefined");
        }
      };
      collection.total = function(arg) {
        if (_.isUndefined(arg)) {
          return allItems.length;
        } else if (_.isFunction(arg)) {
          return _.reduce(allItems, (function(memo, item) {
            if (arg(item)) {
              return 1 + memo;
            } else {
              return memo;
            }
          }), 0);
        } else {
          throw Error(arg + " is expected to be function or undefined");
        }
      };
      collection.replace = function(oldValue, newValue) {
        var i, predicate, _i, _ref;
        predicate = toPredicate(oldValue);
        for (i = _i = 0, _ref = allItems.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (predicate(allItems[i])) {
            allItems[i] = newValue;
          }
        }
        return update.call(collection);
      };
      collection.replaceAll = function(items) {
        assertArray(items);
        allItems = items;
        return update.call(collection);
      };
      collection.get = function(arg) {
        if (_.isFunction(arg)) {
          return _.filter(items, arg);
        } else {
          return items[arg];
        }
      };
      collection.subscribe = function(listener) {
        o.subscribe(listener);
        return this;
      };
      collection._get = function() {
        return items;
      };
      collection._set = function(arg) {
        assertArray(arg);
        allItems = arg;
        return update();
      };
      return collection;
    };
  });

}).call(this);

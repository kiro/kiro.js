// Generated by CoffeeScript 1.4.0
(function() {
  var common, models,
    __slice = [].slice;

  models = window.BC.namespace("models");

  common = window.BC.namespace("common");

  models.collection = function() {
    var allItems, collection, filter, items, o, toArray, toPredicate, update;
    allItems = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    toArray = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 1 && _.isArray(args[0])) {
        return args[0];
      } else {
        return args;
      }
    };
    allItems = toArray.apply(null, allItems);
    items = allItems;
    o = common.observable();
    filter = function() {
      return true;
    };
    collection = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return items;
      } else {
        allItems = toArray.apply(null, args);
        return update();
      }
    };
    update = function() {
      items = _.filter(allItems, filter);
      return o.publish(items);
    };
    toPredicate = function(arg) {
      if (_.isFunction(arg)) {
        return arg;
      } else {
        return function(item) {
          return item === arg;
        };
      }
    };
    collection.add = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      allItems = allItems.concat(toArray.apply(null, args));
      return update.call(collection);
    };
    collection.remove = function(arg) {
      var predicate;
      predicate = toPredicate(arg);
      allItems = _.filter(allItems, function(item) {
        return !predicate(item);
      });
      return update.call(collection);
    };
    collection.removeAll = function() {
      allItems = [];
      return update.call(collection);
    };
    collection.filter = function(arg) {
      filter = toPredicate(arg);
      return update.call(collection);
    };
    collection.count = function(arg) {
      if (_.isUndefined(arg)) {
        return items.length;
      } else if (_.isFunction(arg)) {
        return _.reduce(items, (function(memo, item) {
          if (arg(item)) {
            return 1 + memo;
          } else {
            return memo;
          }
        }), 0);
      } else {
        throw Error(arg + " is expected to be function or undefined");
      }
    };
    collection.total = function(arg) {
      if (_.isUndefined(arg)) {
        return allItems.length;
      } else if (_.isFunction(arg)) {
        return _.reduce(allItems, (function(memo, item) {
          if (arg(item)) {
            return 1 + memo;
          } else {
            return memo;
          }
        }), 0);
      } else {
        throw Error(arg + " is expected to be function or undefined");
      }
    };
    collection.replace = function(oldValue, newValue) {
      var i, predicate, _i, _ref;
      predicate = toPredicate(oldValue);
      for (i = _i = 0, _ref = allItems.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (predicate(allItems[i])) {
          allItems[i] = newValue;
        }
      }
      return update.call(collection);
    };
    collection.replaceAll = function() {
      var newItems;
      newItems = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      allItems = toArray.apply(null, newItems);
      return update.call(collection);
    };
    collection.get = function(arg) {
      if (_.isFunction(arg)) {
        return _.filter(items, arg);
      } else {
        return items[arg];
      }
    };
    collection.subscribe = function(listener) {
      o.subscribe(listener);
      return this;
    };
    return collection;
  };

}).call(this);

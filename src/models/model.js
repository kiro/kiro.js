// Generated by CoffeeScript 1.4.0
(function() {

  window.BC.define('models', function(models) {
    var common, latestObservable, makeObservable, merge;
    common = window.BC.namespace("common");
    models.model = function(arg, o) {
      var model, value;
      value = arg;
      model = function(newValue) {
        var oldValue;
        if (_.isUndefined(newValue)) {
          return value;
        } else {
          oldValue = value;
          value = newValue;
          o.publish(value);
          return oldValue;
        }
      };
      model.toJSON = function() {
        return value;
      };
      if (!o) {
        o = common.observable((function() {
          return model();
        }), function(newValue) {
          return model(newValue);
        });
      }
      return $.extend(model, o);
    };
    latestObservable = null;
    makeObservable = function(value, observable) {
      var item;
      if (common.isModel(value)) {

      } else if (_.isArray(value)) {
        value = models.collection((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            item = value[_i];
            _results.push(makeObservable(item));
          }
          return _results;
        })(), observable);
      } else if (_.isObject(value)) {
        value = models.object(value, observable);
      }
      return value;
    };
    models.object = function(obj, o) {
      var key, keyObservable, listener, observables, prop, result, value;
      if (!_.isObject(obj)) {
        throw Error(obj + " is expected to be an object");
      }
      result = {};
      observables = {};
      if (!o) {
        o = common.observable((function() {
          return result;
        }), function(newValue) {
          return merge(result, newValue);
        });
      }
      for (key in obj) {
        value = obj[key];
        keyObservable = function(key) {
          return common.observable((function() {
            return result[key];
          }), (function(newValue) {
            return result[key] = newValue;
          }));
        };
        observables[key] = keyObservable(key);
        value = makeObservable(value, observables[key]);
        listener = function(key) {
          return function(newValue, valuePath) {
            return o.publish(result, valuePath);
          };
        };
        observables[key].subscribe(listener(key));
        prop = function(key, value) {
          return {
            get: function() {
              latestObservable = observables[key];
              latestObservable.key = key;
              return value;
            },
            set: function(newValue) {
              var oldValue;
              oldValue = value;
              value = makeObservable(newValue, observables[key]);
              observables[key].publish(value, "");
              latestObservable = observables[key];
              return oldValue;
            },
            enumerable: true
          };
        };
        Object.defineProperty(result, key, prop(key, value));
      }
      return $.extend(result, o);
    };
    models.map = function(observable, map) {
      var o, value;
      if (map == null) {
        map = function(x) {
          return x;
        };
      }
      if (!common.isModel(observable)) {
        observable = latestObservable;
      }
      value = map(observable.get());
      o = common.observable((function() {
        return value;
      }), function() {
        throw Error("Mapped values don't support set");
      });
      observable.subscribe(function(newValue, path) {
        value = map(newValue);
        return o.publish(value, path);
      });
      return o;
    };
    models.negate = function(observable) {
      return models.map(observable, function(x) {
        return !x;
      });
    };
    models.bind = function(field) {
      var result;
      if (!latestObservable) {
        throw Error("bind should be used like bind(obj.field)");
      }
      result = latestObservable;
      latestObservable = null;
      return result;
    };
    models.guid = function() {
      var s4;
      s4 = function() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      };
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };
    return merge = function(left, right) {
      var key, value;
      if (common.isModel(right)) {
        throw Error("merge is expected to work only with basic json objects.");
      }
      left.disableNotifications();
      for (key in left) {
        value = left[key];
        latestObservable = null;
        left[key];
        if (latestObservable) {
          if (!_.isArray(right[key]) && _.isObject(right[key])) {
            merge(left[key], right[key]);
          } else {
            left[key] = right[key];
          }
        }
      }
      left.enableNotifications();
      return left.publish(left);
    };
  });

}).call(this);
